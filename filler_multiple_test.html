<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="utf-8" />
    <title>FILLER 4.0 (Beta)</title>

    <style>
        :root {
            --accent: #00695c;
            --bg: #fafbfc;
            --fg: #222;
            --border: #e0e0e0;
            --radius: 8px;
        }
        body {
            font-family: system-ui, sans-serif;
            background: var(--bg);
            color: var(--fg);
            margin: 32px auto;
            max-width: 900px;
            line-height: 1.6;
        }
        h2 {
            font-size: 1.5rem;
            color: var(--accent);
            margin-bottom: 0.5em;
            font-weight: 600;
        }
        fieldset {
            border: 1px solid var(--border);
            border-radius: var(--radius);
            background: #fff;
            padding: 1.5em;
            margin-bottom: 1.5em;
            box-shadow: none;
        }
        legend {
            font-weight: 600;
            color: var(--accent);
            padding: 0 0.5em;
        }
        label {
            font-size: 1em;
            font-weight: 500;
            margin-bottom: 0.25em;
            display: block;
        }
        input, select {
            width: 100%;
            padding: 0.6em;
            border: 1px solid var(--border);
            border-radius: var(--radius);
            background: #fafbfc;
            font-size: 1em;
            margin-bottom: 1em;
            box-sizing: border-box;
        }
        button {
            border: none;
            border-radius: var(--radius);
            padding: 0.7em 1.2em;
            font-size: 1em;
            font-weight: 500;
            background: var(--accent);
            color: #fff;
            cursor: pointer;
            margin-right: 0.5em;
            margin-bottom: 0.5em;
            transition: background 0.2s;
        }
        button:active {
            opacity: 0.9;
        }
        pre {
            background: #f5f5f5;
            border: 1px solid var(--border);
            border-radius: var(--radius);
            padding: 1em;
            font-family: ui-monospace, monospace;
            font-size: 0.98em;
            overflow-x: auto;
        }
        .small {
            font-size: 0.92em;
            color: #666;
        }
        hr {
            border: 0;
            border-top: 1px solid var(--border);
            margin: 1.5em 0;
        }
        .hidden {
            display: none;
        }
        /* --- ESTILOS DE LA TABLA DIN√ÅMICA --- */
        .table-wrapper {
            overflow-x: auto;
            width: 100%;
            padding-bottom: 8px;
            border: 1px dashed var(--border);
            border-radius: var(--radius);
        }
        #tabla-dinamica {
            table-layout: auto;
            width: max-content;
            border-collapse: collapse;
            margin-bottom: 0;
        }
        #tabla-dinamica th, #tabla-dinamica td {
            border: 1px solid var(--border);
            padding: 4px 8px;
            text-align: left;
            font-size: 0.9em;
            white-space: nowrap;
        }
        #tabla-dinamica th {
            background-color: #e0e0e0;
            color: var(--fg);
            font-weight: 600;
            text-transform: uppercase;
            font-size: 0.85em;
        }
        #tabla-dinamica input {
            padding: 5px;
            margin-bottom: 0;
        }
        .iconbtn-delete {
            background: #d32f2f;
            color: white;
            padding: 0.4em 0.6em;
            line-height: 1;
            margin: 0;
            display: block;
            width: 100%;
            text-align: center;
        }
        .iconbtn-delete:hover {
            background: #c62828;
        }
        #tabla-dinamica th:last-child, #tabla-dinamica td:last-child {
            width: 60px;
        }
        input[type="date"] {
            font-size: 0.9em;
        }

        /* --- MODO "UN SOLO REGISTRO" (VERTICAL) --- */
        .table-wrapper.single-record-mode {
            border-style: solid;
        }

        .table-wrapper.single-record-mode #tabla-dinamica {
            width: 100%;
        }

        /* Ocultamos el encabezado cuando solo hay un registro */
        .table-wrapper.single-record-mode thead {
            display: none;
        }

        /* La fila se ve como un bloque */
        .table-wrapper.single-record-mode tbody tr {
            display: block;
        }

        /* Cada celda se apila una debajo de la otra */
        .table-wrapper.single-record-mode tbody tr td {
            display: block;
            border: none;
            padding: 6px 8px 10px;
            white-space: normal;
        }

        /* La √∫ltima celda (la del bot√≥n) la separamos un poquito */
        .table-wrapper.single-record-mode tbody tr td:last-child {
            border-top: 1px solid var(--border);
            margin-top: 4px;
            padding-top: 8px;
        }

        /* Etiqueta encima del input en modo vertical */
        .table-wrapper.single-record-mode .dyn-label {
            display: block;
            font-size: 0.9em;
            font-weight: 500;
            margin-bottom: 2px;
            color: #444;
        }

        /* En modo horizontal, esas etiquetas no se muestran */
        .table-wrapper:not(.single-record-mode) .dyn-label {
            display: none;
        }

        /* Anular el ancho fijo de la columna ACCI√ìN en modo vertical */
        .table-wrapper.single-record-mode #tabla-dinamica th:last-child,
        .table-wrapper.single-record-mode #tabla-dinamica td:last-child {
            width: auto;
        }
    </style>
</head>
<body>
    <h2>FILLER 4.0 (Beta)</h2>

    <div>
        <label>1) Selecciona tu plantilla <small>(.docx)</small></label>
        <input id="fileInput" type="file" accept=".docx" />
        <div class="small">
            Usa marcadores como <code>{{DEMANDANTE}}</code>, <code>{{RADICADO}}</code> o
            <code>{{sentencia.consecutivo}}</code>.
        </div>
    </div>

    <hr />

    <div id="formArea"></div>

    <hr />

    <div style="margin-top: 12px">
        <button id="generateBtn" disabled>Generar y descargar DOCX</button>
        <button id="reloadBtn" class="hidden">Cargar otra plantilla</button>
    </div>

    <h3>Registro de Eventos y Errores:</h3>
    <pre id="log" aria-live="polite"></pre>

    <script>
        (function () {
            const fileInput = document.getElementById("fileInput");
            const formArea = document.getElementById("formArea");
            const generateBtn = document.getElementById("generateBtn");
            const reloadBtn = document.getElementById("reloadBtn");
            const logEl = document.getElementById("log");

            let originalZip = null;
            let templateFilename = null;
            let detectedVars = [];

            const TBODY_ID = "cuerpo-registros-dinamicos";
            const TABLE_CONTAINER_ID = "tableContainer";

            // --- Funci√≥n para cambiar entre modo vertical (1 registro) y horizontal (varios) ---
            function updateLayoutMode() {
                const wrapper = document.getElementById(TABLE_CONTAINER_ID);
                const tbody = document.getElementById(TBODY_ID);
                if (!wrapper || !tbody) return;

                const rows = tbody.querySelectorAll('tr.fila-registro-dinamica');
                if (rows.length <= 1) {
                    // Solo un registro ‚Üí modo vertical
                    wrapper.classList.add('single-record-mode');
                } else {
                    // Varios registros ‚Üí modo tabla horizontal
                    wrapper.classList.remove('single-record-mode');
                }
            }

            // --- Nuevas funciones para la tabla de registros ---

            function construirFila(vars, esModelo = false) {
                const tr = document.createElement('tr');
                tr.className = "fila-registro-dinamica";

                vars.forEach(v => {
                    const td = document.createElement('td');
                    const lower = v.toLowerCase();
                    let inp;

                    if (lower.includes("fecha") && !lower.includes("fechas")) {
                        inp = document.createElement("input");
                        inp.type = "date";
                    } else if (v.includes('.')) {
                        inp = document.createElement("input");
                        inp.type = "text";
                        inp.placeholder = "Valor Anidado para " + v;
                        inp.style.backgroundColor = '#fff3e0';
                    } else {
                        inp = document.createElement("input");
                        inp.type = "text";
                        if (esModelo) inp.placeholder = "Valor para " + v;
                    }

                    inp.name = v;

                    // Etiqueta visible solo en modo "single-record-mode"
                    const labelDiv = document.createElement('div');
                    labelDiv.className = 'dyn-label';
                    labelDiv.textContent = v;

                    td.appendChild(labelDiv);
                    td.appendChild(inp);
                    tr.appendChild(td);
                });

                const tdAccion = document.createElement('td');
                const btnEliminar = document.createElement('button');
                btnEliminar.textContent = 'Eliminar';
                btnEliminar.className = 'iconbtn-delete';
                btnEliminar.onclick = () => eliminarFila(btnEliminar);
                tdAccion.appendChild(btnEliminar);
                tr.appendChild(tdAccion);

                return tr;
            }

            window.agregarFila = function() {
                const cuerpoTabla = document.getElementById(TBODY_ID);
                if (!cuerpoTabla) return;

                const nuevaFila = construirFila(detectedVars, true);
                cuerpoTabla.appendChild(nuevaFila);

                // Re-evaluar el modo (vertical/horizontal)
                updateLayoutMode();
            }

            window.eliminarFila = function(btnElement) {
                const row = btnElement.closest('tr');
                const tbody = document.getElementById(TBODY_ID);

                if (tbody && tbody.querySelectorAll('tr').length > 1) {
                    row.remove();
                } else {
                    if(row) {
                        row.querySelectorAll('input').forEach(input => {
                            input.value = input.type === 'date' ? '' : (input.type === 'number' ? '0' : '');
                        });
                    }
                }

                // Si quedamos con una sola fila, volver a modo vertical
                updateLayoutMode();
            }

            // --- PEGADO: normal en inputs; masivo solo en el primer input de la primera fila ---
            window.handlePaste = function (e) {
              const target = e.target;
              // Si no es un input, no hacemos nada especial.
              if (!(target instanceof HTMLInputElement)) return;

              const clip = (e.clipboardData || window.clipboardData);
              if (!clip) return;
              const pastedData = clip.getData('text');
              if (!pastedData) return;

              const tbody = document.getElementById(TBODY_ID);
              if (!tbody) return;

              // ¬øEs una cuadr√≠cula (p. ej., copiada de Excel o varias l√≠neas)?
              const hasGrid = pastedData.includes('\t') || pastedData.includes('\n');

              // Primer input de la primera fila
              const firstCell = tbody.querySelector('tr.fila-registro-dinamica:first-child input');

              // Solo hacemos pegado masivo si pegamos una cuadr√≠cula EN ese primer input
              const bulkPaste = hasGrid && target === firstCell;

              if (!bulkPaste) {
                // Pegado normal en cualquier otro input/caso
                return; // NO preventDefault => el navegador pega el texto en el campo
              }

              // Pegado masivo
              e.preventDefault();

              // Normalizamos saltos de l√≠nea (por si hay \r\n)
              const rows = pastedData.replace(/\r/g, '').trim().split('\n');

              const numCols = detectedVars.length;
              let rowsProcessed = 0;

              rows.forEach((rowString, rowIndex) => {
                const cells = rowString.split('\t');
                if (!cells.length) return;

                // Primera l√≠nea: reutiliza la primera fila; el resto crea filas nuevas
                let targetRow;
                if (rowIndex === 0) {
                  targetRow = tbody.querySelector('tr.fila-registro-dinamica:first-child');
                } else {
                  targetRow = construirFila(detectedVars, true);
                  tbody.appendChild(targetRow);
                }

                const inputs = targetRow.querySelectorAll('input');
                cells.forEach((cellValue, colIndex) => {
                  if (colIndex < numCols) {
                    const input = inputs[colIndex];
                    if (input) {
                      input.value = String(cellValue).trim();
                    }
                  }
                });

                rowsProcessed++;
              });

              log(`‚úÖ Pegados ${rowsProcessed} registro(s) desde el portapapeles.`);
              // Si se pegaron varias filas, seguramente ahora estamos en modo horizontal
              updateLayoutMode();
            };

            function leerTodosLosContextos() {
                const cuerpoTabla = document.getElementById(TBODY_ID);
                if(!cuerpoTabla) return [];

                const filas = cuerpoTabla.querySelectorAll('tr.fila-registro-dinamica');
                const contextos = [];

                filas.forEach((fila) => {
                    const inputs = fila.querySelectorAll('input');
                    const contexto = {};
                    let camposLlenos = false;

                    inputs.forEach(input => {
                        let valor = input.value.trim();

                        if (input.type === 'date' && valor) {
                            valor = formatDateToSpanish(valor);
                        }

                        setDeep(contexto, input.name, valor);

                        if (valor !== '' && valor !== '0') {
                            camposLlenos = true;
                        }
                    });

                    if (camposLlenos) {
                        contextos.push(contexto);
                    }
                });

                return contextos;
            }

            // --- Funciones de Utilidad (Restantes) ---
            function formatDateToSpanish(dateStr) {
                if (!dateStr) return "";
                const meses = [
                    "enero", "febrero", "marzo", "abril", "mayo", "junio",
                    "julio", "agosto", "septiembre", "octubre", "noviembre", "diciembre"
                ];
                const [year, month, day] = dateStr.split("-");
                return `${parseInt(day)} de ${meses[parseInt(month) - 1]} de ${year}`;
            }
            function loadScript(url) {
                return new Promise((resolve, reject) => {
                    const s = document.createElement("script");
                    s.src = url;
                    s.async = true;
                    s.onload = () => resolve(url);
                    s.onerror = () => reject(url);
                    document.head.appendChild(s);
                });
            }
            async function ensurePizzipAndSaver() {
                const pizUrls = [ "https://unpkg.com/pizzip@3.1.8/dist/pizzip.min.js", "https://cdnjs.cloudflare.com/ajax/libs/pizzip/3.1.5/pizzip.min.js", ];
                const saverUrls = [ "https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js", "https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/1.3.8/FileSaver.js", ];
                let pizLoaded = false;
                for (const u of pizUrls) { try { await loadScript(u); if (typeof window.PizZip !== "undefined") { pizLoaded = true; break; } } catch (e) {} }
                if (!pizLoaded) throw new Error("No se pudo cargar PizZip.");
                let saverLoaded = false;
                for (const u of saverUrls) { try { await loadScript(u); if (typeof saveAs !== "undefined") { saverLoaded = true; break; } } catch (e) {} }
                if (!saverLoaded) throw new Error("No se pudo cargar FileSaver.");
            }
            function log(msg) {
                console.log(msg);
                logEl.textContent += msg + "\n";
                logEl.scrollTop = logEl.scrollHeight;
            }
            function escapeXml(s) {
                if (s == null) return "";
                return String(s).replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
            }
            function setDeep(obj, dottedKey, value) {
                const parts = dottedKey.split(".");
                let cur = obj;
                for (let i = 0; i < parts.length - 1; i++) {
                    const p = parts[i];
                    if (!(p in cur) || typeof cur[p] !== "object") cur[p] = {};
                    cur = cur[p];
                }
                cur[parts[parts.length - 1]] = value;
            }
            function getDeep(obj, dottedKey) {
                const parts = dottedKey.split(".");
                let cur = obj;
                for (let i = 0; i < parts.length; i++) {
                    const p = parts[i];
                    if (cur && typeof cur === "object" && p in cur) {
                        cur = cur[p];
                    } else {
                        return undefined;
                    }
                }
                return cur;
            }
            function extractVarsFromZip(zip) {
                const files = Object.keys(zip.files || {});
                const placeholderRegex = /{{\s*([\w.]+)\s*}}/g;
                const xmlNames = files.filter( (n) => n.startsWith("word/") && n.endsWith(".xml") );
                const varsSet = new Set();
                for (const name of xmlNames) {
                    const fileObj = zip.file(name);
                    if (!fileObj) continue;
                    let xml;
                    try {
                        xml = fileObj.asText();
                    } catch (e) { continue; }
                    const tRegex = /<w:t[^>]*>([\s\S]*?)<\/w:t>/g;
                    let parts = [], m;
                    while ((m = tRegex.exec(xml)) !== null) { parts.push(m[1]); }
                    const combined = parts.join("");
                    let mm;
                    placeholderRegex.lastIndex = 0;
                    while ((mm = placeholderRegex.exec(combined)) !== null) { varsSet.add(mm[1]); }
                }
                return Array.from(varsSet);
            }
            function replacePlaceholdersInXml(xml, replacements) {
                const tRegex = /(<w:t[^>]*>)([\s\S]*?)(<\/w:t>)/g;
                let runs = [];
                let match;
                while ((match = tRegex.exec(xml)) !== null) {
                    runs.push({
                        prefix: match[1],
                        text: match[2],
                        suffix: match[3],
                        start: match.index,
                        full: match[0],
                    });
                }
                if (runs.length === 0) return xml;
                const texts = runs.map((r) => r.text || "");
                const cum = [];
                let s = 0;
                for (let i = 0; i < texts.length; i++) {
                    s += texts[i].length;
                    cum.push(s);
                }
                const combined = texts.join("");
                const placeholderRegex = /{{\s*([\w.]+)\s*}}/g;
                const matches = [];
                let mm;
                while ((mm = placeholderRegex.exec(combined)) !== null) {
                    matches.push({
                        full: mm[0],
                        key: mm[1],
                        index: mm.index,
                        length: mm[0].length,
                    });
                }
                if (matches.length === 0) return xml;
                for (let mi = matches.length - 1; mi >= 0; mi--) {
                    const m = matches[mi];
                    const startIdx = m.index;
                    const endIdx = m.index + m.length - 1;
                    let startRun = 0;
                    while (startRun < cum.length && startIdx >= cum[startRun]) startRun++;
                    const runStartOffset =
                        startRun === 0 ? startIdx : startIdx - cum[startRun - 1];
                    let endRun = 0;
                    while (endRun < cum.length && endIdx >= cum[endRun]) endRun++;
                    const runEndOffset =
                        endRun === 0 ? endIdx : endIdx - cum[endRun - 1];
                    const replRaw = m.key in replacements ? replacements[m.key] : "";
                    const repl = escapeXml(String(replRaw));
                    const before = texts[startRun].slice(0, runStartOffset);
                    const after = texts[endRun].slice(runEndOffset + 1);
                    texts[startRun] = before + repl + after;
                    for (let r = startRun + 1; r <= endRun; r++) texts[r] = "";
                }
                let outXml = "";
                let curPos = 0;
                let ri = 0;
                tRegex.lastIndex = 0;
                while ((match = tRegex.exec(xml)) !== null) {
                    outXml += xml.slice(curPos, match.index);
                    outXml += runs[ri].prefix + texts[ri].replace(/<w:br\/>/g, '') + runs[ri].suffix;
                    curPos = match.index + match[0].length;
                    ri++;
                }
                outXml += xml.slice(curPos);
                return outXml;
            }

            // --- FUNCI√ìN MODIFICADA: CONSTRUYE LA TABLA DE ENTRADA DIN√ÅMICA ---
            function buildForm(vars) {
                formArea.innerHTML = "";

                detectedVars = vars;

                if (!detectedVars || detectedVars.length === 0) {
                    formArea.innerHTML = "<p><i>No se detectaron variables {{...}} en la plantilla.</i></p>";
                    generateBtn.disabled = true;
                    return;
                }

                const fieldset = document.createElement('fieldset');
                const legend = document.createElement('legend');
                legend.textContent = "2) Registros de Documentos a Generar (Generaci√≥n en Bloque)";
                fieldset.appendChild(legend);

                const info = document.createElement("p");
                info.className = "small";
                info.innerHTML = `Variables detectadas (Columnas): <b>${detectedVars.join(", ")}</b>.`;
                fieldset.appendChild(info);

                const tableWrapper = document.createElement('div');
                tableWrapper.className = 'table-wrapper';
                tableWrapper.id = TABLE_CONTAINER_ID;
                tableWrapper.tabIndex = 0;

                const table = document.createElement('table');
                table.id = 'tabla-dinamica';

                const thead = document.createElement('thead');
                const headerRow = document.createElement('tr');
                detectedVars.forEach(v => {
                    const th = document.createElement('th');
                    th.textContent = v;
                    headerRow.appendChild(th);
                });
                const thAccion = document.createElement('th');
                thAccion.textContent = 'ACCI√ìN';
                headerRow.appendChild(thAccion);
                thead.appendChild(headerRow);
                table.appendChild(thead);

                const tbody = document.createElement('tbody');
                tbody.id = TBODY_ID;

                tbody.appendChild(construirFila(detectedVars, true));

                table.appendChild(tbody);
                tableWrapper.appendChild(table);
                fieldset.appendChild(tableWrapper);

                const btnAgregar = document.createElement('button');
                btnAgregar.textContent = '‚ûï A√±adir Fila';
                btnAgregar.onclick = window.agregarFila;
                btnAgregar.style.marginBottom = '1em';
                fieldset.appendChild(btnAgregar);

                formArea.appendChild(fieldset);

                generateBtn.disabled = false;
                reloadBtn.classList.remove("hidden");

                tableWrapper.addEventListener('paste', window.handlePaste);

                // Arrancar en modo vertical (un solo registro)
                updateLayoutMode();
            }

            // === Utilidad para obtener RADICADO desde un contexto (admite claves anidadas) ===
            function getRadicadoFromContext(ctx) {
                // 1) Buscar cualquier variable cuya √∫ltima parte sea "radicado" (insensible a may√∫sculas)
                for (const key of detectedVars) {
                    const last = key.split('.').pop();
                    if (last && last.toLowerCase() === 'radicado') {
                        const val = getDeep(ctx, key);
                        if (val) return String(val).trim();
                    }
                }
                // 2) Fallback r√°pido
                if (ctx && (ctx.RADICADO || ctx.radicado)) {
                    return String(ctx.RADICADO || ctx.radicado).trim();
                }
                return '';
            }

            // --- FUNCI√ìN PRINCIPAL: Generaci√≥n y Descarga en Bloque ---
            window.generateAndDownload = function() {
                try {
                    if (!originalZip) {
                        log("No hay plantilla cargada.");
                        return;
                    }

                    const contextos = leerTodosLosContextos();

                    if (contextos.length === 0) {
                        log("üö´ No hay registros v√°lidos para generar documentos.");
                        return;
                    }

                    log(`Generando ${contextos.length} documento(s) en bloque...`);

                    const generatedBlobs = [];
                    const baseFilename = (templateFilename || "plantilla").replace(/\.docx$/i, "");
                    const now = new Date();
                    const dd = String(now.getDate()).padStart(2, '0');
                    const mm = String(now.getMonth() + 1).padStart(2, '0');
                    const yy = String(now.getFullYear()).slice(-2);
                    const fecha = `${dd}-${mm}-${yy}`;

                    let count = 0;

                    contextos.forEach((ctx, index) => {
                        const replacements = {};

                        detectedVars.forEach((k) => {
                            const parts = k.split(".");
                            let cur = ctx;
                            let val = "";
                            for (const p of parts) {
                                if (cur && typeof cur === "object" && p in cur) cur = cur[p];
                                else {
                                    cur = null;
                                    break;
                                }
                            }
                            if (cur != null && cur !== undefined) val = cur;
                            replacements[k] = val;
                        });

                        try {
                            const ab = originalZip.generate
                                ? originalZip.generate({ type: "arraybuffer" })
                                : originalZip;
                            const zip2 = new PizZip(ab);
                            const files = Object.keys(zip2.files || {});
                            const xmlNames = files.filter(
                                (n) => n.startsWith("word/") && n.endsWith(".xml")
                            );

                            for (const name of xmlNames) {
                                const f = zip2.file(name);
                                if (!f) continue;
                                let xml = f.asText();
                                const newXml = replacePlaceholdersInXml(xml, replacements);
                                if (newXml !== xml) {
                                    zip2.file(name, newXml);
                                }
                            }

                            const outBlob = zip2.generate({
                                type: "blob",
                                mimeType:
                                    "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
                            });

                            // Mantener un "name" utilitario para archivos internos
                            generatedBlobs.push({
                                blob: outBlob,
                                index: index + 1,
                                name: ctx[detectedVars[0]] || `Doc_${index+1}`
                            });
                            count++;
                        } catch (err) {
                            log(`‚ùå Error al generar documento #${index + 1}: ${err.message}`);
                        }
                    });

                    if (generatedBlobs.length === 0) {
                        log("‚ùå No se pudo generar ning√∫n documento. Revisa los errores.");
                        return;
                    }

                    if (generatedBlobs.length === 1) {
                        // Documento √∫nico
                        const radicado = getRadicadoFromContext(contextos[0]);
                        const outName = `${radicado ? radicado + '_' : ''}${baseFilename}_${fecha}.docx`;
                        saveAs(generatedBlobs[0].blob, outName);
                        log(`‚úÖ Documento √∫nico generado: ${outName}`);
                    } else {
                        // Varios -> ZIP
                        if (typeof window.JSZip === 'undefined') {
                            log("‚ö†Ô∏è Se requiere la librer√≠a JSZip para descargar varios documentos en un solo archivo.");
                            // Fallback: descargar el primero con un nombre razonable
                            const fallbackName = `${baseFilename}_Doc_1_${fecha}.docx`;
                            saveAs(generatedBlobs[0].blob, fallbackName);
                            log(`‚úÖ Se generaron ${count} documentos. Descargado el primero como: ${fallbackName}`);
                        } else {
                            const zipArchiver = new JSZip();
                            generatedBlobs.forEach(item => {
                                const namePart = item.name.toString().replace(/[^a-zA-Z0-9]/g, '_').substring(0, 30);
                                zipArchiver.file(`${baseFilename}_${namePart}_${item.index}.docx`, item.blob);
                            });

                            zipArchiver.generateAsync({ type: "blob" }).then(zipBlob => {
                                const zipName = `${baseFilename}_${fecha}.zip`;
                                saveAs(zipBlob, zipName);
                                log(`‚úÖ ${count} documentos generados y comprimidos en: ${zipName}`);
                            });
                        }
                    }

                } catch (err) {
                    console.error(err);
                    log("‚ùå Error al generar (general): " + (err && err.message ? err.message : err));
                }
            }

            // --- Funciones de Carga y Eventos (Restantes) ---
            window.onFileSelected = async function(ev) {
                logEl.textContent = "";
                generateBtn.disabled = true;
                formArea.innerHTML = "<p>Procesando plantilla‚Ä¶</p>";
                detectedVars = [];
                const f = ev.target.files && ev.target.files[0];
                if (!f) {
                    formArea.innerHTML = "<p>No seleccionaste archivo.</p>";
                    return;
                }
                templateFilename = f.name;
                try {
                    await loadScript("https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js");
                    await ensurePizzipAndSaver();
                } catch (e) {
                    formArea.innerHTML = `<p style="color:crimson">Error cargando dependencias: ${e.message}</p>`;
                    log("Error al cargar librer√≠as: " + e.message);
                    return;
                }
                const reader = new FileReader();
                reader.onload = function (e) {
                    try {
                        const arrayBuffer = e.target.result;
                        const zip = new PizZip(arrayBuffer);
                        originalZip = zip;
                        detectedVars = extractVarsFromZip(zip);

                        if (detectedVars.length === 0) {
                            formArea.innerHTML =
                                "<p><i>No se encontraron variables {{...}}. Aseg√∫rate de usar llaves dobles.</i></p>";
                            log("No se detectaron variables.");
                            generateBtn.disabled = true;
                            return;
                        }
                        buildForm(detectedVars);
                        log("Plantilla procesada. Variables: " + detectedVars.join(", "));
                    } catch (err) {
                        console.error(err);
                        formArea.innerHTML =
                            "<p style='color:crimson'>Error procesando el .docx: " +
                            (err && err.message ? err.message : err) +
                            "</p>";
                        log("Error interno: " + (err && err.stack ? err.stack : err));
                        generateBtn.disabled = true;
                    }
                };
                reader.readAsArrayBuffer(f);
            }

            fileInput.addEventListener("change", window.onFileSelected);
            generateBtn.addEventListener("click", window.generateAndDownload);
            reloadBtn.addEventListener("click", () => {
                fileInput.value = "";
                formArea.innerHTML = "";
                logEl.textContent = "";
                generateBtn.disabled = true;
                reloadBtn.classList.add("hidden");
            });
        })();
    </script>
</body>
</html>
